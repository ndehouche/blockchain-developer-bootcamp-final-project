
const PasswordManager = artifacts.require("PasswordManager");

    


contract('PasswordManager', ([ownerAccount, client1, client2]) => {

    let passwordManager;
    const domain1 = "0x646f6d61696e3100000000000000000000000000000000000000000000000000";
    const password1 = "0x70617373776f7264310000000000000000000000000000000000000000000000";
    const domain2 = "0x646f6d61696e3200000000000000000000000000000000000000000000000000";
    const password2 = "0x70617373776f7264320000000000000000000000000000000000000000000000";

    before(async () => {
        passwordManager = await PasswordManager.new()  
    })


    describe('Variables', async () => {
        // This test checks if the contract has an owner. Since the contract inherits from Ownable (OpenZeppelin), owner is automatically generated.
        // And since owner is public, a getter "owner" function should be automatically generated.
        // The test checks that such a function is present. The test should pass.
        it("should have an owner", async () => {
            assert.equal(typeof passwordManager.owner, 'function', "the contract has no owner.");
          });
        // This test checks if the owner of the contract is the address that deployed the contract.
        // The test should pass.
        it('owner is deployer of contract (account[0])', async () => {
            const owner = await passwordManager.owner()
            assert.equal(owner, ownerAccount, 'The deployer is not the owner.')
        } );
        // This test checks if there is a function (balance()). This is autogenerated if there is a public variable named (balance).
        // The test should pass.
        it("should have a balance", async () => {
            assert.equal(typeof passwordManager.balance, 'function', "the contract has no balance.");
          });
    })

    describe('saveNewPassword function', async () => {
        // This test checks if users can save new passwords. 
        //If a password is saved, result will be true and the unencyptedPart of the password struct retrieved will equal domain1.
        // The test should pass.
        it("should allow users to store new passwords to password list", async () => {
            

    const result = await passwordManager.saveNewPassword(domain1, password1, {from: client1
    });
           const result2 = await passwordManager.saveNewPassword(domain2, password2, {from: client1
    });
           const passwordList =  await passwordManager.getPasswordList({ from: client1
    });

            
            assert(result,
            "Users cannot save passwords.",
            );
        
              assert.equal(passwordList[0].unencryptedPart,
                domain1, 
                "Passwords are not stored in a list",
              );
        })
    })

    describe('deletePassword function', async () => {
        // This test checks if users can delete passwords. If a password is delted, the password list length should be less by one.
        // The test should pass.
        it("should allow users to delete passwords saved.", async () => {
            const result = await passwordManager.deletePassword(1, {from: client1});
            const passwordList = await passwordManager.getPasswordList({ from: client1});

        assert.equal(
            passwordList.length,
            1, // We had saved two passwords above, and now deleted one, so should be left with one password.
            "Passwords could not be deleted.",
          );
        })
    })

    describe('getPasswordList function', async () => {
        // This test checks that users can retrieve the list of passwords they stored. 
        // This is confirmed if the length of the passwords array is equal to the number of passwords saved. 
        //The test saves two more passwords and checks that the password list now contains three passwords.
        // The test should pass.
        it("Password List length should equal number of passwords saved.", async () => {
            const result = await passwordManager.saveNewPassword(domain1, password1, {from: client1
     });
            const result2 = await passwordManager.saveNewPassword(domain2, password2, {from: client1
     });
            const passwordList = await passwordManager.getPasswordList({ from: client1
     });

        assert.equal(
            passwordList.length,
            3,
            "Password List length not the same as number of passwords saved by user.",
          );
        })
        // This test checks that each user has access only to their password list. 
        //The test saves one password for client 2 and checks that their password list contains 1 password (not 3 passwords).
        // The test should pass.
        it("Each user should only have access to their password list.", async () => {
            const result = await passwordManager.saveNewPassword(domain1, password1, {from: client2 });
            const passwordList = await passwordManager.getPasswordList({ from: client2 });

        assert.equal(
            passwordList.length,
            1,
            "Password List length not the same as number of passwords saved bu user.",
          );
        })
    })

})
  